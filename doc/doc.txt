各位好，我是来自tps platform team *****，今天给大家演示的是 使用CQRS架构模型来提高我们的应用的效率


首先我们看CQRS架构模型，简单的说，就是一个系统，从架构上把它拆分为两部分：
//这里一张架构图
命令处理（写/请求）+查询处理（读请求）。
然后读写两边可以用不同的架构实现,因为大部分系统都是读多写少，以实现CQ两端（即Command Side，简称C端；Query Side，简称Q端）的分别优化。

这里主要来介绍各种的CQRS的组件

command Bus: 用来处理从前端接受到各种command(新增，修改，删除命令), command bus会自动路由到对应的command handler来处理

和传统的架构相比:
1.CQRS 架构最终一致性，而传统架构是强一直性;
2.CQRS 架构更加的复杂，引入了新的组件,学习的成本比传统架构要高；
3.CQRS 扩展性更强（大量运用了事件驱动），传统架构组件之间耦合，很难扩展
4.架构可用性两者都有各种方案能做高可用
5.CQRS 架构性能优化的方案会更多，毕竟是读写分离了，可以分开优化Q端和C端的性能问题。
传统架构门槛低，懂的人也多，且因为大部分项目都没有什么大的并发写入量和数据量。所以应该说大部分项目，采用传统架构就OK了。
但是通过分析，传统架构确实也有一些缺点，比如在扩展性、可用性、性能瓶颈的解决方案上，都比CQRS架构要弱一点;


我们来现在来模拟一个业务场景，我们的业务中，用户在前端选择一种债券（cusip）来创建一条trade; 在整个链路中，创建trade 需要调用refData service(比较耗时，需要异步);
然后返回给前端一个tradeid,最后用户可以查到这个条trade的状态是否成功;

业务结合cqrs模型图:
// 正在画

然后演示下整个业务的流程的操作(swager):


在整个链路中,出了业务本身的耗时外，异步线程的调度，事件的转发都是比较耗时的,追求极致的qps,我们还做了关于这方面的性能优化;

//在常用的juc框架模型中,大部分使用了锁的机制，而我们知道虽然jdk已经在这方面加入了锁偏向，读写锁等手段，但是一旦并发量上来，使用锁还是容易造成性能问题。
由于cpu的cache line的，当需要并发读写的多个变量存在一个cache lines上，还会产生伪共享的问题；
线程池才用阻塞队列和锁来实现的task的调度：
jdk中队列的比较:
队列名字	是否加锁	数据结构	关键技术点	是否有锁	是否有界
ArrayBlockingQueue	是	数组array	ReentrantLock	有锁	有界
LinkedBlockingQueue	是	链表	ReentrantLock	有锁	有界
LinkedTransferQueue	否	链表	CAS	无锁	无界
DelayQueue	否	堆Heap	CAS	无锁	无界

我们可以看见，我们无锁的队列是无界的，有锁的队列是有界的，这里就会涉及到一个问题，我们在真正的线上环境中，无界的队列，对我们系统的影响比较大，有可能会导致我们内存直接溢出，所以我们首先得排除无界队列，当然并不是无界队列就没用了，只是在某些场景下得排除。
其次还剩下ArrayBlockingQueue，LinkedBlockingQueue两个队列，他们两个都是用ReentrantLock控制的线程安全，他们两个的区别一个是数组，一个是链表，在队列中，一般获取这个队列元素之后紧接着会获取下一个元素，或者一次获取多个队列元素都有可能，而数组在内存中地址是连续的，在操作系统中会有缓存的优化(下面也会介绍缓存行)，所以访问的速度会略胜一筹，我们也会尽量去选择ArrayBlockingQueue
为什么jdk会增加一些无锁的队列，其实就是为了增加性能，很苦恼，又需要无锁，又需要有界

disrutpor: cas 无锁，消除了伪共享，ringbuffer的结构

1.ringbuffer的图:


所以我们在框架中抛弃掉了使用了线程池来作为异步执行，我们使用了Disruptor来做异步的处理：


Rinfbufer的api 用ut展示


最后演示一条trade的 创建流程

todo: 更多的异常处理方式的封装

#ringBuffer 如何读取数据？
所有的消费者都会在记录一个sequence,来标记已经消费的序列号，然后不停的用cas去做更新操作

MESI协议来保证跨cpu的一致性








